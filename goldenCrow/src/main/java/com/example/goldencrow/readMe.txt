plan은 내부 구조 전달용 샘플입니당
대체로 특화 때 코드를 참고하시면 됩니다

JPA 작성에서 특히 주의해야 할 것
- 엔티티
    - seq 컬럼은 int 대신 Long 추천
    - 시간을 관리하는 엔티티 컬럼은 @Temporal(어쩌고) 가 붙어야 함
    - 변수명을 통일시킬 것이기 때문에, @Column만 붙이면 되고 (name=어쩌고)는 필요없다. (특화 참고)
    - join을 표현할 땐 해당 테이블의 엔티티로 받아온다
    - join은 가급적 ManytoOne을 쓰자 (양방향 써도 되긴 함)
- dto
    - entity는 절대!! 통째로!! 반환하지 않는다!! 같은 내용이더라도 dto를 준비하자
    - dto에서 엔티티를 입력받는 생성자를 만들어두면 노가다 작업이 줄어든다 (특화 참고)
- 레포지토리
    - JPA 인터페이스를 받아오기 : extends JpaRepository<해당엔티티이름, 해당엔티티의pk타입>
    - 정 jpa로 안되면 네이티브 쿼리를 사용할 수 있지만, 가급적이면 쓰지 말자 (특화 참고)
    - dto로 바로 받아올 순 없다. List나 엔티티로 받은 뒤에 for-each 돌려서 dto로 반환하자
        (특화 참고 추천, plan에도 있겠지만 구조가 좀 다름)
- 서비스 & 컨트롤러
    - 상세한 로직은 가급적 서비스 내에서 작성한다
    - 컨트롤러에서는 가급적 상세한 로직을 쓰지 않는다
    - 컨트롤러의 반환은 ResponseEntity로 해야 한다 (plan엔 없는 내용임! 특화 참고!)
    - 가급적이면 컨트롤러에서 직접 레포지토리에 접근하지 않는다 (서비스에서 해주세용)
- 기타
    - 엔티티 <-> 레포지토리 <-> 서비스 <-> 컨트롤러
    - 특화의 좋은 예시 : users 혹은 pieces

- 코드리뷰 후기
    - Optional 옵션을 사용했다면 isPresent로 검사한 뒤에 .get() 하자
    - resource (인풋스트림, 버퍼드리더 등) 를 사용할 때
           - finally를 통해 close() 하거나
           - try-with-resource 구문을 사용한다
    - Java-Linux 작업 시에는 InterruptedException을 따로 catch 해준다
    - BoxedType (long 말고 Long 같은) 쓸 때는 == 말고 !=null && equals()를 쓴다